# Создание неизменных классов

Типы возвращаемых данных в неизменных классах

Когда вы пишете неизменный класс, будьте осторожны с типами возвращаемых данных. На первый взгляд, этот класс кажется неизменным, так как нет установщика:

public class NotImmutable {  
 private StringBuilder builder;  
 public NotImmutable(StringBuilder b) { 
    builder = b;  
 }  
 public StringBuilder getBuilder() {
     return builder;   
} }
Проблема в том, что это не совсем так. Рассмотрим этот фрагмент кода:

StringBuilder sb = new StringBuilder("initial");
NotImmutable problem = new NotImmutable(sb);
sb.append(" added");
StringBuilder gotBuilder = problem.getBuilder();
gotBuilder.append(" more");
System.out.println(problem.getBuilder());
Это выводит - "initial added more"явно не то, что мы намеревались. Проблема в том, что мы просто передаем одно и то же StringBuilder.
У вызывающей стороны есть ссылка, так как она была передана конструктору. Любой, кто вызывает геттер, тоже получает ссылку.
Решение состоит в том, чтобы сделать копию изменяемого объекта. Это называется защитной копией.

public Mutable(StringBuilder b) { 
 builder = new StringBuilder(b);
}
public StringBuilder getBuilder() { 
 return new StringBuilder(builder);
}
Теперь вызывающая сторона может вносить изменения в исходный sbобъект, и это нормально. Mutableбольше не заботится об этом объекте после запуска конструктора. 
То же самое касается геттера: вызывающие абоненты могут изменять их, StringBuilderне влияя Mutable.
Другой подход для получателя - вернуть неизменный объект:

public String getValue() {
  return builder.toString();
}
Нет правила, согласно которому мы должны возвращать тот же тип, который мы храним. Stringбезопасно вернуться, потому что он неизменен в первую очередь.
Чтобы проверить, инкапсуляция относится к предотвращению непосредственного изменения вызывающими сторонами переменных экземпляра.
Неизменяемость относится к тому, чтобы запретить вызывающим сторонам изменять переменные экземпляра вообще.

Создание JavaBeans


Инкапсуляция настолько распространена в Java, что существует стандарт для создания классов, хранящих данные, который называется JavaBeans.
A JavaBean- это принцип проектирования для инкапсуляции данных в объекте в Java. В таблице 2.1 перечислены правила именования JavaBeans.
Таблица 2.1 Соглашения об именах JavaBean

правило	пример
Свойства есть private.	private int age;
Геттер для не booleanсвойств начинается с get.	public int getAge() {   return age;}
Получатели booleanсвойств могут начинаться с isили get.	public boolean isBird() {   return bird;}public boolean getBird() {   return bird;}
Методы установки начинаются с set.	public void setAge(int age) {   this.age = age;}
Имя метода должно иметь префикс set/ get/, isза которым следует первая буква свойства в верхнем регистре,
а затем остальная часть имени свойства.	public void setNumChildren (int numChildren) {   this.numChildren = numChildren;}
Хотя booleanзначения используют isдля запуска их метод получения, это не относится к экземплярам класса-оболочки Boolean, которые используют get.
Давайте посмотрим на некоторые примеры. Допустим, privateв нашем классе определены следующие две переменные:

private boolean playing;
private Boolean dancing;
Что из следующего может быть правильно включено в JavaBean?

public boolean isPlaying() { return playing;}
public boolean getPlaying() { return playing; }
public Boolean isDancing() { return dancing; }

Первая строка верна, потому что она определяет правильный метод получения booleanпеременной. Второй пример также верен, поскольку booleanможет использовать isили get.
Третья строка неверна, потому что Booleanоболочка должна начинаться с get, поскольку это объект. Как насчет этих примеров?

public String name;
public String name() { return name; }
public void updateName(String n) { name = n; }
public void setname(String n) { name = n; }
Ни одна из этих строк не соответствует правильной практике JavaBean! Первая строка делает name public, тогда как должно быть private. 
Вторая строка не определяет правильный получатель и должна быть getName(). Последние две строки являются неверными установщиками, поскольку первая не начинается с,
setа вторая не имеет первой буквы атрибута nameв верхнем регистре.  


Создание неизменных классов

Инкапсуляция данных полезна, потому что она предотвращает неконтролируемые изменения в вашем классе.
Другой распространенный метод - сделать классы неизменяемыми, чтобы их нельзя было изменить вообще.
Неизменяемые занятия полезны, потому что вы знаете, что они всегда будут одинаковыми. 
Вы можете передать их вашему приложению с гарантией того, что абонент ничего не изменил.
Это помогает сделать программы проще в обслуживании. Это также помогает повысить производительность, ограничивая количество копий, 
как вы видели Stringв главе 3 «Базовые API Java».
Один из шагов в создании неизменяемого класса - опустить сеттеры. Но подождите: мы все еще хотим, 
чтобы вызывающая сторона могла указать начальное значение - мы просто не хотим, чтобы оно изменилось после создания объекта.
Конструкторы на помощь!
В этом примере у нас нет сеттера. У нас есть конструктор, который позволяет установить значение. 
Помните, неизменность измеряется только после того, как объект построен.
Неизменяемые классы могут иметь значения. Они просто не могут измениться после создания экземпляра.
У вызывающей стороны есть ссылка, так как она была передана конструктору. Любой, кто вызывает геттер, тоже получает ссылку.
Решение состоит в том, чтобы сделать копию изменяемого объекта (в конструкторе) Это называется защитной копией.
Теперь вызывающая сторона может вносить изменения в исходный sb объект, и это нормально. NotImmutable не заботится об этом объекте
после запуска конструктора.
То же самое касается геттера: вызывающие абоненты могут изменять их, StringBuilder не влияя NotImmutable



1.	Используйте конструктор, чтобы установить все свойства объекта.
2.	Отметьте все переменные экземпляра privateи final.
3.	Не определяйте методы установки.
4.	Не позволяйте ссылочным изменяемым объектам изменяться или получать к ним доступ напрямую.
5.	Предотвратить переопределение методов.
Первое правило определяет, как мы создаем неизменяемый объект, передавая информацию конструктору, чтобы все данные устанавливались при создании.
Второе и третье правила просты, поскольку они проистекают из правильной инкапсуляции. Если переменными экземпляра являются privateи final, и нет методов установки, тогда нет прямого способа изменить свойство объекта. Все ссылки и примитивные значения, содержащиеся в объекте, задаются при создании и не могут быть изменены.
Четвертое правило требует немного большего объяснения. Допустим, у вас есть неизменный Animalобъект, который содержит ссылку на Listлюбимую пищу животного, как показано в следующем примере:

import java.util.*
 public final class Animal { 
  private final List<String> favoriteFoods;   
 public Animal(List<String> favoriteFoods) {    
  if(favoriteFoods == null) {    
     throw new RuntimeException("favoriteFoods is required");  
    }    
  this.favoriteFoods = new ArrayList<String>(favoriteFoods);  
 }    
public List<String> getFavoriteFoods() {
 // MAKES CLASS MUTABLE!   
   return favoriteFoods; 
  }}
Чтобы убедиться, что favoriteFoods Listэто не так null, мы проверяем его в конструкторе и выкидываем исключение, если оно не предоставлено. 
  Проблема в этом примере заключается в том, что пользователь имеет прямой доступ к Listопределенному в нашем экземпляре Animal.
  Даже если они не могут изменить Listобъект, на который он указывает, они могут изменить элементы List, например, удалив все элементы с помощью вызова getFavoriteFoods().clear(). Они также могут заменить, удалить или даже отсортировать List.
Таким образом, решение никогда не состоит в том, чтобы вернуть эту Listссылку пользователю. В более общем виде, вы никогда не должны делиться ссылками на изменяемый объект, содержащийся в неизменяемом объекте. Если пользователю нужен доступ к данным в List, либо создайте методы-обертки для итерации по данным,
  либо создайте одноразовую копию данных, которые возвращаются пользователю и никогда не сохраняются как часть объекта. На самом деле CollectionsAPI включает Collections.unmodifiableList()метод, который делает именно это. Ключевым моментом здесь является то, что ни один из создаваемых вами методов не должен изменять изменяемый объект.
Возвращаясь к нашим пяти правилам, последнее правило важно, потому что оно не позволяет кому-либо создать подкласс вашего класса, в котором ранее неизменяемое значение теперь выглядит изменчивым. Например, они могут переопределить метод, который изменяет другую переменную в подклассе,
  по существу скрывая privateпеременную, определенную в родительском классе. Самое простое решение - пометить класс или методы finalмодификатором, хотя это ограничивает использование класса. Другой вариант - создать конструктор privateи применить шаблон фабрики, который мы обсудим позже в этой главе.


